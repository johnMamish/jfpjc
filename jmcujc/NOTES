One big thing that I'm struggling with is a tradeoff between data copying/duplication and code ease
of use/flexibility. If I want code to be flexible and easy to use, I think that I need some sort of
abstraction layer between the input buffering and the data structures from which jmcujc pulls its
input. Doing more operations in-place would save me time and space, hoever, I think that this would result in less flexible code that's harder to read and write from a user perspective (well, as well as an implementer prespective). One option that's on my mind is doing calculations like debayering/rgb to intensity&chrom as the DCT code pulls in pixels. While this definately has the smallest memory footprint, it puts extra code inside an inner loop and is unclear if it saves computational speed over code that modifies the input line-by-line and reads it into a new location.

Another concern: if I make this code preprocess input on a line-by-line basis, the processor has to be free on every new line to handle debayering / RGB->Lum/Chrom. This is fine in an RTOS environment where the debayering code can pre-empt the DCT/huffman coding code, but in a baremetal environment, it implies that we need to be able to process an entire row of DCT/huffman encodings in the space of a single line, unless we want to do the line processing inside the ISR (we don't).
The simplest way around this is to waste more memory and have an option (or a default) to increase the size of the input buffer to match the height of the strips. Of course, if we do this, we will increase our memory footprint by 30-100% (depending on the subsampling of the different components).
Even if we do this, we still need to get through the jpeg encoding in almost exactly the same amount of time that it takes to read the image in. We can't zap an image in in 10 millis, shut the image sensor off, and spend 100 millis encoding the image. To do that, we would need an image buffer large enough to store the whole image. Maybe it's a good idea to just KISS and chew through an assload of memory.
I suppose that what I'd like ideally is easily configurable buffer size options and a way for the code to know whether its buffer has been encroached upon or not.
